#!/usr/bin/env node
'use strict';

const findCacheDir = require('find-cache-dir');
const { program } = require('commander');

const {
  existsSync,
  mkdirSync,
  writeFileSync,
  rmSync,
  symlinkSync,
  renameSync,
  lstatSync,
  rmdirSync,
  readlinkSync,
} = require('fs');

const { join } = require('path');
const stripAnsi = require('strip-ansi');

program
  .name('Bottled Ember')
  .description('A handy version of Ember that you can take with you whever you go!')
  .version(require(`${__dirname}/../package.json`).version);

program.enablePositionalOptions();

program
  .option('--ember-version <string>', 'The Ember version that you want bottled ember to generate for you. Default: 4.0', '4.0')
  .option('--cache-name <string>', 'A suffix to add to your cached Bottled Ember folder so you can have multiple apps with the same version', 'default')
  .option('--no-overlay', 'Tuns off the default behaviour of overlaying `app` and `tests` folders into your Bottled Ember app')
  .option('--deps <string>', 'A comma seperated list of extra dependencies you would like to install into your Bottled Ember App')
  .option('--links <string>', 'A comma seperated list of folders you want to link into the Bottled Ember App. You can provide these in the format `source:destination` or you can just provide one folder name and it will be used as both source and destination')
  .option('--output-path <string>', 'The dist folder for your Bottled Ember App. You only need to set this when you are running multiple apps at the same time', 'dist')
  .option('-p, --port <number>', 'The port to run you Bottled Ember App on if you are running locally')
  .option('--environment <string>', 'Passes the environment through to the Bottled Ember app e.g. --environment production');

program.argument('[command]', 'The command you want to pass to your Bottled Ember App.', 'serve');

program.parse();
const options = program.opts();

const emberVersion = options.emberVersion;

let cacheDir;

if (process.env.BOTTLED_CACHE_DIR) {
  cacheDir = process.env.BOTTLED_CACHE_DIR;
} else {
  cacheDir = findCacheDir({
    name: `bottled-ember-${emberVersion.replace(/\./g, '-')}-${options.cacheName}`,
  });
}

async function run() {
  const execa = (await import('execa')).execa;

  if (!existsSync(cacheDir)) {
    console.log('generating your bottled-ember app now 🤖');
    mkdirSync(cacheDir, { recursive: true });

    await execa('npm', ['-v']);

    // this prevents ember-cli from thinking it's already in an ember addon/app
    // when running from the cache directory. Adding a package.json just short-circuits
    // the mechanism that ember-cli uses to identify that it's already in an app/addon
    writeFileSync(join(cacheDir, 'package.json'), '{}');

    const initCommand = execa(
      'npx',
      [`ember-cli@${emberVersion}`, 'init', '--skip-npm', '--no-welcome'],
      {
        cwd: cacheDir,
      }
    );

    initCommand.stdout.setEncoding('utf8');

    initCommand.stdout.on("data", (data) => {
      if(data.includes(stripAnsi("Overwrite package.json?"))) {
        initCommand.stdin.write("y\n");
      }
    })

    await initCommand;

    console.log(`bottled-ember app finished initialising 🤖`);

    writeFileSync(join(cacheDir, '.npmrc'), 'auto-install-peers=true');

    if (!process.env.BOTTLED_SKIP_DEPENDENCIES) {
      console.log('installing dependencies 🤖');

      await execa('npx', ['pnpm', 'install'], {
        cwd: cacheDir,
      });

      console.log('finished installing dependencies 🤖');
    } else {
      console.log('skipping installing dependencies 🤖');
    }

    console.log('customising bottled-ember app 🤖');

    await rmSync(join(cacheDir, 'app/templates/application.hbs'));

    await renameSync(
      join(cacheDir, 'config/environment.js'),
      join(cacheDir, 'config/old-environment.js')
    );

    await writeFileSync(
      join(cacheDir, 'config/environment.js'),
      `const oldEnvironment = require('./old-environment');

    module.exports = function(environment) {
      const ENV = oldEnvironment(environment);

      try {
        const newEnvironment = require('${join(process.cwd(), 'config')}');

        const newEnv = newEnvironment(environment);

        return {
          ...ENV,
          ...newEnv,
        }
      } catch {
        return ENV;
      }
    }`
    );

    await rmSync(join(cacheDir, 'ember-cli-build.js'));

    await writeFileSync(
      join(cacheDir, 'ember-cli-build.js'),
      `'use strict';

      const EmberApp = require('ember-cli/lib/broccoli/ember-app');
      const mergeTrees = require('broccoli-merge-trees');
      const { join } = require('path');
      const { existsSync } = require('fs');
      let buildConfig = {}

      try {
        const localConfig = require('${join(process.cwd(), 'config')}');

        if (localConfig['ember-cli-build']) {
          buildConfig = localConfig['ember-cli-build'];
        }
      } catch {
        // do nothing
      }

      let trees = {};

      // todo make no-overlay work at runtime so you don't need to clear cache
      if (${options.overlay ? true : false} && existsSync(join('${process.cwd()}', 'app'))) {
        trees.app = mergeTrees([join(__dirname, 'app'), join('${process.cwd()}', 'app')], { overwrite: true })
      }

      if (${options.overlay ? true : false} && existsSync(join('${process.cwd()}', 'tests'))) {
        trees.tests = mergeTrees([join(__dirname, 'tests'), join('${process.cwd()}', 'tests')], { overwrite: true })
      }

      module.exports = function (defaults) {
        let app = new EmberApp({
          ...defaults,
          trees,
        }, buildConfig);
        return app.toTree();
      };
`
    );

    console.log('installing linking your local app 🤖');

    await execa('npx', ['pnpm', 'install', process.cwd()], {
      cwd: cacheDir,
    });

    console.log('bottled-ember app successfully generated 🦾');
  } else {
    console.log('re-using existing bottled-ember app 🤖');
  }

  if (options.deps) {
    const deps = options.deps.split(',');

    const pkg = require(`${cacheDir}/package.json`);

    if (!deps.every(dep => pkg.dependencies?.[dep])) {
      console.log('installing your personal dependencies 🤖');
      await execa('npx', ['pnpm', 'install', ...deps], {
        cwd: cacheDir,
      });

      console.log('finished installing your personal dependencies 🤖');
    } else {
      console.log('keeping exising deps 🤖');
    }
  }

  if (options.links) {
    const links = options.links.split(',');

    links.forEach((link) => {
      let source, destination;

      if (link.includes(':')) {
        let split = link.split(':');
        source = split[0];
        destination = split[1];
      } else {
        source = destination = link;
      }

      const destiantionPath = join(cacheDir, destination);
      const sourcePath = join(process.cwd(), source);

      if (existsSync(destiantionPath)) {
        const stats = lstatSync(destiantionPath);

        if (!stats.isSymbolicLink() || readlinkSync(destiantionPath) !== sourcePath) {
          rmdirSync(destiantionPath, {
            recursive: true,
            force: true,
          });
        }
      }

      if (!existsSync(destiantionPath)) {
        console.log(`linking ${source} -> ${destination} 🤖`);
        symlinkSync(sourcePath, destiantionPath);
      }
    });
  }

  const commandArgs = ['ember', program.args[0] || 'serve'];

  commandArgs.push('--output-path', join(process.cwd(), options.outputPath));

  if (options.port) {
    commandArgs.push(`--port=${options.port}`);
  }

  if (options.environment) {
    commandArgs.push('--environment', options.environment);
  }

  if (!process.env.BOTTLED_SKIP_COMMAND) {
    await execa(
      'npx',
      commandArgs,
      {
        cwd: cacheDir,
        stderr: 'inherit',
        stdout: 'inherit',
      }
    );
  }

}

run();
